# Курсовая работа "Алгоритм Хаффмана"

Целью данной курсовой работы является написание веб приложения на языке PHP. Данное приложение сжимает данные с помощью алгоритма Хаффмана.

Для достижения поставленной цели необходимо решить следующие

взаимосвязанные задачи:

- Познакомиться с алгоритмом Хаффмана;

- Выбрать оптимальное средство разработки;

- Разработать веб приложение на языке PHP;

- Протестировать приложение.


# Описание Алгоритма

Алгоритм Хаффмана — жадный алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью. Был разработан в 1952 году аспирантом Массачусетского технологического института Дэвидом Хаффманом при написании им курсовой работы. В настоящее время используется во многих программах сжатия данных.

В отличие от алгоритма Шеннона — Фано, алгоритм Хаффмана остаётся всегда оптимальным и для вторичных алфавитов m2 с более чем двумя символами.

Этот метод кодирования состоит из двух основных этапов:

- Построение оптимального кодового дерева.

- Построение отображения код-символ на основе построенного дерева


Идея алгоритма состоит в следующем: 

зная вероятности появления символов в сообщении, можно описать процедуру построения кодов переменной длины, состоящих из целого количества битов. Символам с большей вероятностью ставятся в соответствие более короткие коды. Коды Хаффмана обладают свойством префиксности (то есть ни одно кодовое слово не является префиксом другого), что позволяет однозначно их декодировать.

Классический алгоритм Хаффмана на входе получает таблицу частот встречаемости символов в сообщении.

Далее на основании этой таблицы строится дерево кодирования Хаффмана (Н-дерево).

Символы входного алфавита образуют список свободных узлов. 

Каждый лист имеет вес, который может быть равен либо вероятности, либо количеству вхождений символа в сжимаемое сообщение.

Выбираются два свободных узла дерева с наименьшими весами.

Создается их родитель с весом, равным их суммарному весу.

Родитель добавляется в список свободных узлов, а два его потомка удаляются из этого списка.

Одной дуге, выходящей из родителя, ставится в соответствие бит 1, другой — бит 0. Битовые значения ветвей, исходящих от корня, не зависят от весов потомков.

Шаги, начиная со второго, повторяются до тех пор, пока в списке свободных узлов не останется только один свободный узел. Он и будет считаться корнем дерева. 

Этот процесс можно представить как построение дерева, корень которого — символ с суммой вероятностей объединенных символов, получившийся при объединении символов из последнего шага, его n0 потомков — символы из предыдущего шага и т. д.

Чтобы определить код для каждого из символов, входящих в сообщение, мы должны пройти путь от листа дерева, соответствующего текущему символу, до его корня, накапливая биты при перемещении по ветвям дерева (первая ветвь в пути соответствует младшему биту). Полученная таким образом последовательность битов является кодом данного символа, записанным в обратном порядке.

Классический алгоритм Хаффмана имеет ряд существенных недостатков. 

Во-первых, для восстановления содержимого сжатого сообщения декодер должен знать таблицу частот, которой пользовался кодер. Следовательно, длина сжатого сообщения увеличивается на длину таблицы частот, которая должна посылаться впереди данных, что может свести на нет все усилия по сжатию сообщения. Кроме того, необходимость наличия полной частотной статистики перед началом собственно кодирования требует двух проходов по сообщению: одного для построения модели сообщения (таблицы частот и Н-дерева), другого для собственно кодирования. 

Во-вторых, избыточность кодирования обращается в ноль лишь в тех случаях, когда вероятности кодируемых символов являются обратными степенями числа 2. 

В-третьих, для источника с энтропией, не превышающей 1 (например, для двоичного источника), непосредственное применение кода Хаффмана бессмысленно.


# Описание программы

Программа представлена на рисунках 1-5. Поле для кодирования данных, на выходе получаем закодированную строку, данные необходимые для декодирования, построенную таблицу для кодирования и дерево для декодирования. Поле декодирование, декодирует строку с помощью данных для декодирования которые преобразуются в дерево, по которому уже идет декодирование.

![](Aspose.Words.440cd1cb-1a64-4e20-9307-2ddf12354d17.002.png)

Рисунок 1 - Кодирование

![](Aspose.Words.440cd1cb-1a64-4e20-9307-2ddf12354d17.003.png)

Рисунок 2 - Декодирование

![](Aspose.Words.440cd1cb-1a64-4e20-9307-2ddf12354d17.004.png)

Рисунок 3 - Данные для декодирования

![](Aspose.Words.440cd1cb-1a64-4e20-9307-2ddf12354d17.005.png)

Рисунок 4 - Таблица для кодирования

![](Aspose.Words.440cd1cb-1a64-4e20-9307-2ddf12354d17.006.png)

Рисунок 5 - Дерево

# Заключение

В процессе выполнения курсовой работы был изучен алгоритм Хаффмана, методы создания веб приложений на языке PHP, основные конструкции языка, методы программирования и тестирования приложений с помощью библиотеки PHPUnit, а также была изучена интегрированная среда разработки PHPShtorm.

Следствием выполнения курсовой работы является достижение поставленной цели – написание веб приложения для сжатия данных методом Хаффмана.


# Список использованных источников

1. Алгоритм Хаффмана на пальцах [Электронный ресурс] https://habr.com/ru/post/144200/ (дата обращения: 20.04.2020)

1. Документация PHPunit [Электронный ресурс] https://phpunit.readthedocs.io/ru/latest/installation.html (дата обращения: 29.04.2020)

1. Алгоритм Хаффмана [Электронный ресурс]  https://en.wikipedia.org/wiki/Huffman\_coding (дата обращения: 29.04.2020)

1. Томас Кормен: Алгоритмы. Вводный курс. Издательство: Вильямс, 2019 г.


